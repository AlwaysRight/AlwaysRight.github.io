---
layout: post
title: "树"
date: 2017-05-11
description: "leetcode题解，树"
tag: leetcode-算法讲解
---   

### 树
  * 二叉查找树
  * 树的遍历
  * 平衡树

### 树的高度

#### 111. Minimum Depth of Binary Tree
求树的最短深度（叶子节点到根的最小距离）  <strong>注意此题子树深度为0时，并没有叶子节点，要特殊处理</strong>  另外一种做法是层序遍历，用队列的结构，根据size或者每层push一个特殊node来判断层数。直到遇到一个叶子节点。 层序遍历比深度优先的递归更效率些。因为它不用查到最后一层

```c++

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == NULL){
            return 0;
        }
        int left = minDepth(root->left);
        int right = minDepth(root->right);
        return ((left < right && left != 0) || right == 0) ? (left + 1) : (right + 1);
    }
};
```

### 树的各种遍历

* 中序

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> s;
        vector<int> result;

        TreeNode * cur = root;
        while(cur || !s.empty()){
            while(cur){
                s.push(cur);
                cur = cur->left;
            }
            TreeNode * tmp = s.top();
            s.pop();
            result.push_back(tmp->val);
            cur = tmp->right;
        }
        return result;
    }

};
```

* 前序遍历。 和上面类似，只是在入栈左节点时，顺便打印了。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
       vector<int> result;
		if (!root) {
			return result;
		}
		stack<TreeNode *> s;
		TreeNode * node = root;
		while (node || !s.empty()) {
			while (node) {
				result.push_back(node->val);
				s.push(node);
				node = node->left;
			}
			node = s.top()->right;
			s.pop();
		}
		return result;
    }
};
```

* 后序遍历

PostOrder is a little different from the inorder and preoder. when we get  a most left node called cur , we can not print it and should traverse the right subtree of it firstly. and when we back to the cur after traverse all the right subtree, we should print the cur. So we need a flag to represent if it is the first time to travese cur or not.

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

struct ele{
     TreeNode* root;
     int flag;
     ele(TreeNode* r, int f):root(r),flag(f){}
 };
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<ele> s;
        TreeNode* cur = root;
        while(cur || !s.empty()){
            while(cur){
                s.push(ele(cur, 0));
                cur = cur->left;
            }
            ele e = s.top();
            if(e.flag){
                result.push_back(e.root->val);
                s.pop();
            }else{
                cur = e.root->right;
                s.top().flag =  1;
            }
        }
        return result;
    }
};
```

* 层序遍历

第一层数目为1. 当pop 出1个时， 此时也全加入了第二层的元素。所以此时的队列大小就是第二层的大小。记录下来为size。 pop出size个后再记录下第三层的大小。。。以此类推

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode *> q;
        vector<vector<int>> result;
        if(root == NULL){
            return result;
        }
        TreeNode* cur = root;
        q.push(cur);
        vector<int> tmp;
        int size =  1;
        while(!q.empty()){
            cur = q.front();
            q.pop();
            size--;
            tmp.push_back(cur->val);
             if(cur->left != NULL){
                q.push(cur->left);
            }
            if(cur->right != NULL){
                q.push(cur->right);
            }
            if(size == 0){
                result.push_back(tmp);
                tmp.clear();
                size = q.size();
            }
        }
        return result;
    }
};
```
#### 582. Kill Process
Given n processes, each process has a unique PID (process id) and its PPID (parent process id). 每个进程有一个父进程id, 可能有多个子进程id. kill一个进程 并且把他的子进程也全杀掉
给出 pid 已经相应的ppid数组, 首先可以用广搜

```c++
lass Solution {
public:
    vector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {
        unordered_map<int, vector<int>> map;
        for(int i = 0; i < pid.size(); i++){
            if(map.find(ppid[i]) != map.end()){
                map[ppid[i]].push_back(pid[i]);
            }else{
                vector<int> v;
                v.push_back(pid[i]);
                map.insert(make_pair(ppid[i], v));
            }

        }
        vector<int> res;
        res.push_back(kill);
        int start = 0;
        while(1){
            unordered_map<int, vector<int>>::iterator it = map.find(res[start]);
            if(it != map.end()){
                for(int j = 0; j <  it->second.size(); j ++){
                    res.push_back(it->second[j]);

                }
            }
            start ++;
            if(start == res.size()){
                break;
            }
        }
        return res;
    }
};
```

然后还有深度优先搜索的方法：

```c++
class Solution {
public:
    vector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {
        vector<int> killed;
        map<int, set<int>> children;
        for (int i = 0; i < pid.size(); i++) {
            children[ppid[i]].insert(pid[i]);
        }
        killAll(kill, children, killed);
        return killed;
    }

private:
    void killAll(int pid, map<int, set<int>>& children, vector<int>& killed) {
        killed.push_back(pid);
        for (int child : children[pid]) {
            killAll(child, children, killed);
        }
    }
};
```


### 动态规划与递归
#### 96. Unique Binary Search Trees
Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

思路： 可以很容易的退出递推式，1-n,分别可以以n个节点做根，若以i做根，那么它可构成的个数为 f(i-1)*f(n-i)  相加即可
可以用递归做， 但是超时。 所以用数组存下

```c++
class Solution {
public:
    int numTrees(int n) {
      int ff[n + 1];
      ff[0] = 1;
      ff[1] = 1;
      for(int i = 2; i <= n; i++){
          ff[i] = 0;
          for(int j = 1; j <= i; j++){
              ff[i] += ff[j - 1]* ff[i - j];
          }
      }
      return ff[n];

      // return f(n);
    }

    // int f(int i){
    //     if(i == 1 || i ==0){
    //         return 1;
    //     }
    //     int r = 0;
    //     for(int j = 1; j <= i; j++){
    //         r += f(j-1)*f(i-j);
    //     }
    //     return r;
    // }
};
```

#### 95. Unique Binary Search Trees II Add to List

DescriptionHintsSubmissionsSolutions
Total Accepted: 80086
Total Submissions: 257753
Difficulty: Medium
Contributor: LeetCode
Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1...n.

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        if(n == 0){
            return vector<TreeNode*>(0);
        }
        return help(1, n);
    }

    vector<TreeNode*> help(int start, int end) {
        vector<TreeNode*> result;
        if(start > end){
            result.push_back(NULL);
            return result;
        }else if(start == end){
            result.push_back(new TreeNode(start));
            return result;
        }
         for(int i = start; i <= end; i++){
            vector<TreeNode*> left = help(start, i - 1);
            vector<TreeNode*> right = help(i+1, end);
            for(int k = 0; k < left.size(); k++){
                for(int j = 0; j < right.size(); j++){
                	TreeNode* root = new TreeNode(i); // 注意每个树都要自己new节点
                	root->left = left[k];
                    root->right = right[j];
                    result.push_back(root);
                }
            }
        }
        return result;
    }
};
```

#### 100 Same Tree

简单题， 就是判断条件的时候， 可以简写。
```c++
bool isSameTree(TreeNode* p, TreeNode* q) {
    if (!p || !q) return q == p;
    return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
}
```

####572. Subtree of Another Tree
此题可以直接遍历 然后利用上题的same tree 判断。
另外一种思路是，这个过程特别像字符串匹配的过程，先遍历成字符串，就转换成了求是否为子串（KMP算法）问题。但我还没想明白怎么建立树的字符串，只是遍历建立的话会有样例不正确的。
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSubtree(TreeNode* s, TreeNode* t) {
        bool f = isEqualtree(s, t);
        if(f){
            return true;
        }else if(s == NULL){
            return false;
        }
        bool lf = isSubtree(s->left, t);
        if(lf){
            return lf;
        }
        bool rf = isSubtree(s->right, t);
        if(rf){
            return rf;
        }
        return false;
    }

    bool isEqualtree(TreeNode* s, TreeNode* t) {
        if(s== NULL || t == NULL){
            return s == t;
        }
        if(s->val != t->val){
            return false;
        }

        return isEqualtree(s->left, t->left) && isEqualtree(s->right, t->right);
    }
};
```

#### 101. Symmetric Tree
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
就是判断一棵树是否对称。
* 思路1： 可以按照上题思路，最左右子树递归判断， 只是值相等的地方要左右交换

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root == NULL){
            return true;
        }
        return help(root->left, root->right);
    }

    bool help(TreeNode *left, TreeNode * right){
        if(!left || !right){
            return left == right;
        }
        return left->val == right->val && help(left->right, right->left) && help(left->left, right->right);
    }
};
```

* 思路2： 用两个队列，每层从左到右和从右到左入队列。

```c++
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode *root) {
        TreeNode *left, *right;
        if (!root)
            return true;

        queue<TreeNode*> q1, q2;
        q1.push(root->left);
        q2.push(root->right);
        while (!q1.empty() && !q2.empty()){
            left = q1.front();
            q1.pop();
            right = q2.front();
            q2.pop();
            if (NULL == left && NULL == right)
                continue;
            if (NULL == left || NULL == right)
                return false;
            if (left->val != right->val)
                return false;
            q1.push(left->left);
            q1.push(left->right);
            q2.push(right->right);
            q2.push(right->left);
        }
        return true;
    }
};
```

#### 563. Binary Tree Tilt

Given a binary tree, return the tilt of the whole tree.

The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.

The tilt of the whole tree is defined as the sum of all nodes' tilt.

Example:
Input:
         1
       /   \
      2     3
Output: 1
Explanation:
Tilt of node 2 : 0
Tilt of node 3 : 0
Tilt of node 1 : |2-3| = 1
Tilt of binary tree : 0 + 0 + 1 = 1

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int findTilt(TreeNode* root) {
        int tilt = 0;
        findTilt(root, tilt);
        return tilt;
    }
    int findTilt(TreeNode* root, int& tilt){
        if(root == NULL){
            return 0;
        }
        int lSum = 0, rSum = 0;
        if(root->left){
            lSum = findTilt(root->left, tilt);
        }
        if(root->right){
            rSum = findTilt(root->right, tilt);
        }
        tilt  += abs(lSum - rSum);
        return root->val + lSum + rSum;
    }
};
```
#### 98 合法bst的判断
思路一： 每个节点都应该有个最大最小的限制，用递归的思路写出来
```c++
bool isValidBST(TreeNode* root) {
    return isValidBST(root, NULL, NULL);
}

bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {
    if(!root) return true;
    if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)
        return false;
    return isValidBST(root->left, minNode, root) && isValidBST(root->right, root, maxNode);
}
```
思路二： 中序遍历， 如果某个节点小于前面一个了，那么非法。 当然可以用栈的形式遍历， 或者直接递归遍历

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        TreeNode* prev = NULL;
        return validate(root, prev);
    }
    bool validate(TreeNode* node, TreeNode* &prev) {
        if (node == NULL) return true;
        if (!validate(node->left, prev)) return false;
        if (prev != NULL && prev->val >= node->val) return false;
        prev = node;
        return validate(node->right, prev);
    }
};
```

####  99 Recover Binary Search Tree

恢复二叉查找树中 唯一一对颠倒的节点数据

思路: 中序遍历 ，相当于排序好的数组中有一对交换了顺序 比如： 1 2  3 4 5， 交换后1 5 3 4 2， 找到一个逆序的（5,3）， 5为交换的点之一，第二个逆序的（4,2），2为交换点。遍历可以通过递归进行， 分别设置两个节点记录颠倒的点。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
private:
    TreeNode* first = NULL;
    TreeNode* second = NULL;
    TreeNode* prevElement = new TreeNode(INT_MIN);
public:
    void recoverTree(TreeNode* root) {
        t(root);
        int tmp = second->val;
        second->val = first->val;
        first->val = tmp;
    }
    void t(TreeNode * root){
        if(!root){
            return;
        }
        t(root->left);
        if(!first && prevElement->val > root->val){
            first = prevElement;
        }
        if(first!=NULL && prevElement->val > root->val){
            second = root;
        }
        prevElement = root;
        t(root->right);
    }
};
```

这道题的真正符合要求的解法应该用的Morris遍历，这是一种非递归且不使用栈，空间复杂度为O(1)的遍历方法，可参见我之前的博客Binary Tree Inorder Traversal 二叉树的中序遍历，在其基础上做些修改，加入first, second和parent指针，来比较当前节点值和中序遍历的前一节点值的大小，跟上面递归算法的思路相似，代码如下：

重复以下1、2直到当前节点为空

1. 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。

2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点（即当前节点的左子树的最右节点）。

   a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点（利用这个空的右孩子指向它的后缀）。当前节点更新为当前节点的左孩子。

   b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。


```c++
// Now O(1) space complexity
class Solution {
public:
    void recoverTree(TreeNode *root) {
        TreeNode *first = NULL, *second = NULL, *parent = NULL;
        TreeNode *cur, *pre;
        cur = root;
        while (cur) {
            if (!cur->left) {
                if (parent && parent->val > cur->val) {
                    if (!first) first = parent;
                    second = cur;
                }
                parent = cur;
                cur = cur->right;
            } else {
                pre = cur->left;
                while (pre->right && pre->right != cur) pre = pre->right;
                if (!pre->right) {
                    pre->right = cur;
                    cur = cur->left;
                } else {
                    pre->right = NULL;
                    if (parent->val > cur->val) {
                        if (!first) first = parent;
                        second = cur;
                    }
                    parent = cur;
                    cur = cur->right;
                }
            }
        }
        if (first && second) swap(first->val, second->val);
    }
};
```
