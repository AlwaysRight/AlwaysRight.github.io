---
layout: post
title: "Hash表的原理及例题讲解"
date: 2017-04-10
description: "leetcode题解，hash查找"
tag: 算法
---   

## Hash数据结构：
　hash表可以提供快速的插入操作和查找操作。需要首先申请较大的空间，将元素根据特定规则求key,散列到不同的空间位置。<br>
<strong>哈希表散列方法：
+ 直接定址法
+ 数字分析法
+ 平方取中法
+ 折叠法
+ 除留余数法
+ 随机数法<br>

<strong>哈希表处理冲突方法：
+ 开放定址法：当冲突时， 重新计算地址 H = (H(key) + di) MOD m
  * di = 1, 2, 3...时，线性探测再散列, 能保证只要表未满，就能找到空位，但是会造成“二次聚集”： 如下一个地址为 i,i + 1,i+2的元素都会争夺后一个空位。
  * di = 1^2, -1^2, 2^2, -2^2...k^2, -k^2.. 二次探测再散列。
  * di = 伪随机数序列， 称作伪随机探测再散列
+ 链地址法

## leetcode 相关题目
### 1. Intersection of Two Arrays(349)

Given two arrays, write a function to compute their intersection.<br>
Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].<br>
解法： 1 排序用two pointer，注意去重； 2 hash表索引，注意去重<br>

```c++
  vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
      vector<int> result;
      unordered_set<int> s(nums1.begin(), nums1.end());
      for(int i = 0; i < nums2.size(); i++){
          if(s.count(nums2[i])){
              result.push_back(nums2[i]);
              s.erase(nums2[i]);
          }
      }
      return result;
  }
```

### 2. Two Sum(1)
Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].

```c++
  vector<int> twoSum(vector<int>& nums, int target) {
     vector<int> result;
     unordered_map<int, int> map;
     for(int i = 0; i < nums.size(); i++){
         unordered_map<int, int>::iterator x = map.find(target - nums[i]);
         if(x != map.end()){
             result.push_back(x->second);
             result.push_back(i);
             break;
         }
         map[nums[i]] = i;
     }
     return result;
 }
```
### 3. Longest Substring Without Repeating Characters(3)
Given a string, find the length of the longest substring without repeating characters.

Examples:

Given "abcabcbb", the answer is "abc", which the length is 3.

Given "bbbbb", the answer is "b", with the length of 1.

Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring.

```c++
int lengthOfLongestSubstring(string s) {
        if(s.size()== 0){
            return 0;
        }
        int max = 0;
        unordered_map<char, int> map;
        int pre = 0;
        for(int i = 0; i < s.size(); i++){
            unordered_map<char, int>::iterator it;
            it = map.find(s[i]);
            if(it != map.end()){
              //注意substring开始界限的更新 比如abba ， it->second + 1
              //能比 pre 小
                pre = pre > it->second + 1 ? pre : it->second + 1;
                it->second = i;
            }else{
                pair<char, int> ss (s[i], i);
                map.insert(ss);
            }
            max = max >= (i - pre + 1)? max: (i - pre + 1);
        }
        return max;
    }
```
### 4 Max Points on a Line(149)

```c++
/**
 * Definition for a point.
 * struct Point {
 *     int x;
 *     int y;
 *     Point() : x(0), y(0) {}
 *     Point(int a, int b) : x(a), y(b) {}
 * };
 */
class Solution {
public:
    int maxPoints(vector<Point>& points) {
        map<pair<int, int>, int> slopes;
        int maxp = 0, n = points.size();
        for (int i = 0; i < n; i++) {
            slopes.clear();
            int duplicate = 1;
            int localMax = 0;
            for (int j = i + 1; j < n; j++) {
                if (points[j].x == points[i].x && points[j].y == points[i].y) {
                    duplicate++;
                    continue;
                }
                int dx = points[j].x - points[i].x;
                int dy = points[j].y - points[i].y;
                int dvs = gcd(dx, dy);
                pair<int, int> ppp(dx / dvs, dy / dvs);
                slopes[ppp]++;
                localMax = max(localMax,  slopes[ppp]);
            }
            maxp = max(maxp, localMax + duplicate);
        }
        return maxp;
    }
private:
    int gcd(int num1, int num2) {
        while (num2) {
            int temp = num2;
            num2 = num1 % num2;
            num1 = temp;
        }
        return num1;
    }
};
```
