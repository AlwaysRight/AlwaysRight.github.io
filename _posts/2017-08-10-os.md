---
layout: post
title: "操作系统面试复习"
date: 2017-08-10
description: "os"
tag: 面试知识准备
---   



#### 1 死锁的四个条件：
* 互斥使用(Mutual exclusion) ：
指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。

* 不可抢占(No preemption)：
指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

* 请求和保持(Hold and wait)：
指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

* 循环等待(Circular wait)：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

#### 2 进程间通信
* 消息传递（管道（PIPE） 命名管道（FIFO） 消息队列）
* 同步（互斥量（mutex）、条件变量、读写锁、文件和写记录锁、信号量（pv操作？））
* 共享内存（匿名的和具名的）
* 远程过程调用（Solaris门和Sun RPC）

http://blog.csdn.net/shaohui973/article/details/8142797

#### 3 I/O
https://segmentfault.com/a/1190000003063859


### 进程
#### 1 进程概念
进程是一个程序及其数据（进程实体）在处理机上顺序执行时所发生的活动，是系统进行资源分配和调度的一个独立单位。具有动态性，并发性，独立性，异步性。

进程实体： 程序段、数据段、PCB

进程状态：创建 就绪（等cpu） 运行  阻塞（i/o，申请缓冲区失败） 终止

PCB: (1) 独立运行基本单位的标志，进程配置了PCB后表示它是一个能独立运行的合法基本单位<br/>
(2) 实现间断性运行方式， 可以保留CPU现场信息 <br/>
(3) 提供进程管理所需要的信息（程序和数据的地址；文件、IO设备等资源清单） <br/>
(4) 进程调度信息：状态，优先级 <br/>
(5) 实现与其他进程的同步与通信， （消息队列指针，信号量）
pcb的组织方式（想想linux源码里的task[64]?） (1)线性组织 （2）相同状态的链接组织（3）索引

#### 2 进程控制
用户态：执行规定指令，访问指定的寄存器和存储区  系统态：执行一切指令，访问所有寄存器和存储区

挂起（suspend）:静止就绪（阻塞）；-> 激活（active）

#### 3 进程同步
##### 概念：
定义： 对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的顺序（规则）共享系统资源，并能很好的相互合作，从而使得程序的执行具有可再现性。

同步制约：1）间接相互制约关系 （都需要打印机资源） 2）直接制约 （B需要A的数据）

临界区：多个进程必需要互斥对临界资源进行访问，所以再每个进程访问临界资源的代码叫临界区
##### 硬件同步机制：注意锁测试和关锁操作必须连续，不允许分开 如何保证？
* 关中断  就是在测试所之前关闭中断（防止其他进程线程切换），加锁后再打开
* test-and-set 指令实现（硬件指令）
* SWAP 指令  key 临时变量设为true, while(key){ swap(&lock, &key)} (测试的同时，上锁)

##### 信号量机制
P(wait(s)), V(signal(s))
* 整形信号量  （忙等）
* 记录型信号量 （让权等待）  记录一个等待进程链表指针list  （P53页）
* AND型信号量 一次性分配给进程需要的所有资源，使用完毕后一起释放

```c++
 typedef struct{
   int value;
   struct process_control_block *list
 }
   wait(Semmaphore S){
     s--;
     if(s->value < 0){
       block(s->list);
     }
   }

   signal(Semaphore S){
     s->value++;
     if(s->value++ <= 0){
       //可以唤醒一个等待的进程
       wakeup(s->list);
     }
   }
```
##### 经典同步问题
1）生产者-消费者
```c++
int in = 0, out = 0;
item buffer[n];
Semaphore mutex = 1, empty = n, full = 0;

void proceducer(){
   do{
     proceduce an item nextp;
     ..
     wait(empty);
     wait(mutex);
     buffer[in] = nextp;
     in := (in +1) % n;
     signal(mutex);
     signal(full);
   }
}
消费者也是类似的。 要在添加商品和取出商品的时候加互斥锁。防止存储混乱。
```

2）哲学家就餐问题
* 假设有n个哲学家 至多允许n-1 个哲学家去申请筷子
* 仅当左右筷子都可用时，再申请   AND信号量
* 规定奇数号的哲学家先拿左，偶数号的哲学家先拿右

3）读者-写者问题  P65
* 可以多个一起读
* 写和读要互斥， 只有没有人读的时候才能写。
